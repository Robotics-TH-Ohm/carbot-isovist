package isovist;

import basics.math.Geom;
import basics.points.PointCloudCreator2D;
import basics.points.PointList2D;
import java.util.ArrayList;
import robotinterface.Robot;
import robotinterface.RobotController;
import robotinterface.RobotGeomUtil;
import robotinterface.Time;
import robotinterface.lss.LidarPackageSlam;
import robotinterface.lss.LidarSlamWorldModelPoint;
import robotinterface.lss.LidarSubsystem;
import robotinterface.lss.LidarSubsystemListenerSlam;
import robotinterface.lss.ObservedLidarPointSlam;
import robotinterface.mss.AsyncMotionMessage;
import robotinterface.mss.AsyncMotionMessageBundle;
import robotinterface.mss.MotionSubsystem;
import robotinterface.mss.MotionSubsystemListener;
import robotlib.driver.Driver;
import robotlib.driver.RegulatedAheadDriver;
import robotlib.nav.Pos2PosRouting;
import robotlib.nav.grid.Grid_Astar;
import robotlib.nav.grid.Pos2PosRoutingGrid;
import robotlib.navtraj.NavTrajPlanning;
import robotlib.navtraj.NavTrajSplitPlanning;
import robotlib.navtraj.RouteTraj;
import robotlib.traj.TrajectoryPlanner;
import robotlib.traj.longrange.LongrangePlanner;
import robotlib.traj.longrange.LongrangeProfile;
import robotlib.traj.seq.Maneuver;
import robotlib.traj.seq.TrajectorySequence;
import robotlib.worldmodel.ObstacleContainer;
import robotlib.worldmodel.ObstaclePoint;

import java.util.ArrayList;

import basics.points.PointCloudCreator2D;
import basics.points.PointList2D;
import robotinterface.Robot;
import robotinterface.RobotController;
import robotinterface.Time;
import robotinterface.debug.DebugPainterOverlay;
import robotinterface.lss.LidarPackageSlam;
import robotinterface.lss.LidarSubsystem;
import robotinterface.lss.LidarSubsystemListenerSlam;
import robotinterface.mss.AsyncMotionMessageBundle;
import robotinterface.mss.MotionSubsystemListener;
import robotlib.driver.Driver;
import robotlib.worldmodel.ObstacleContainer;
import robotlib.worldmodel.ObstaclePoint;

import isovist.model.Grid;
import isovist.model.Cell;
import isovist.model.Coordinate;
import isovist.strategies.BoustrophedonStrategy;
import isovist.strategies.Strategy;
import isovist.strategies.WallFollowStrategy;

/**
 * Reinigungsaufgabe AMR Wintersemester 2021
 * Basis Clean1.java aus dem Carbot Starter Package
 * 
 * @author Nils Weber <weberni76153@th-nuernberg.de>
 */
public class Clean
    extends RobotController
    implements MotionSubsystemListener, LidarSubsystemListenerSlam {

  private RobotDriver robotDriver = null; // Custom robot driver
  private Grid grid = new Grid();
  private double[] startPos = null;

  private ObstacleContainer obstaclesLidar = null; // Container, der alle bisher gefundenen Hindernispunkte enthält

  public Clean() {
    Robot.motionSubsystem.registerMotionListener(this);

    // Ohne Lidar kann diese Anwendung nicht laufen -> dann sofort beenden
    if (Robot.lidarSubsystem == null) {
      Robot.debugOut.println(
          "No Lidar Subsystem available - I cannot see anything!");
      return;
    }

    // Lidar-SLAM-Mechanismus einrichten
    try {
      Robot.lidarSubsystem.setTiming(LidarSubsystem.EQUIDISTANT, 1000);
      Robot.lidarSubsystem.registerLidarListenerSlam(this);
      Robot.lidarSubsystem.setMSSCorrection(true);
    } catch (UnsupportedOperationException e) {
      Robot.debugOut.println(
          "Lidar Subsystem does not provide SLAM-correction");
    }

    // Hindernis-Karte einrichten
    obstaclesLidar = new ObstacleContainer(
        PointCloudCreator2D.TYPE_GRID,
        10.0d,
        ObstacleContainer.ADD_MODE_FUSION_WEIGHT,
        3.0d); // FUSION_MAX_LIDAR_DIST

    // Custom robot driver
    robotDriver = new RobotDriver(obstaclesLidar, Robot.debugPainter.getOverlay("Driver"));
  }

  @Override
  public String getDescription() {
    return ("Robot controller " +
        getClass().getName() +
        " by Nils Weber <weberni76153@th-nuernberg.de> for AMR2021");
  }

  @Override
  public boolean requiresConfiguration() {
    return false;
  }

  @Override
  public void configure(String params) {
    switch (params) {
      case "TACTILE":
        robotDriver.setTactileObstacles(true);
        break;
    }
  }

  // Helper
  private void paintObstacles() {
    double[][] obstacles = ObstacleContainer.getObstactles2D(obstaclesLidar);
    DebugPainterOverlay ovl = Robot.debugPainter.getOverlay("Obstacles");
    ovl.clear();
    for (int i = 0; i < obstacles.length; i++)
      ovl.fillCircle(obstacles[i][0], obstacles[i][1], 5, 0, 0, 0, 255);
    ovl.paint();
  }

  public void setup() throws Exception {
    Robot.debugOut.println("Instantiate Motion Planning...");
    robotDriver.instantiateMotionPlanning(); // So aufwändig, dass in eigene Methode ausgelagert
    Robot.debugOut.println("Motion Planning instantiated");

    Robot.debugOut.println("Startup Robot facilities...");
    // Lidar-System einrichten und starten
    if (Robot.lidarSubsystem == null) {
      Robot.debugOut.println(
          "Navigation without Lidar Subsystem not possible!");
      return;
    }

    try {
      Robot.lidarSubsystem.resetWorldModel();
    } catch (UnsupportedOperationException e) {
      Robot.debugOut.println("Lidar Subsystem does not use a World Model");
    }

    Robot.lidarSubsystem.startup();

    // MSS konfigurieren
    Robot.motionSubsystem.sendCommand("stoprule T");
    Robot.motionSubsystem.sendCommand("rotaterule T");
    Robot.debugOut.println("Robot facilities started");

    Time.sleep(2000); // 2s warten, damit
    // - der Lidar hochgefahren ist (Rotation hat Endgeschwindigkeit)
    // - es ein paar Lidar-Scans gibt und damit die Scans schon richtig ausgerichtet
    // auf der Karte liegen
    // - das MSS die ersten Positionen gemeldet hat
  }

  @Override
  public void run() throws Exception {
    setup();

    DebugPainterOverlay pathOverlay = Robot.debugPainter.getOverlay("Path");

    // Initialize cleaning routine
    startPos = Robot.motionSubsystem.estimateCurrentPosition();
    grid.set(startPos, new Cell(Cell.START));

    // Cleaning strategies for the two phases
    Strategy boustrophedon = new BoustrophedonStrategy(grid);
    Strategy wallFollow = new WallFollowStrategy(grid, robotDriver);

    Strategy currentStrategy = boustrophedon;
    Coordinate currentPos = grid.worldToGrid(Robot.motionSubsystem.estimateCurrentPosition());
    Coordinate nextTarget = null;

    Robot.debugOut.sayToast("Starting Boustrophedon Strategy");
    boolean isClean = false;
    while (!isClean) {
      // Get the next target
      nextTarget = currentStrategy.getNextTarget(currentPos);

      // Switch strategies or stop cleaning
      if (nextTarget == null) {
        if (currentStrategy == wallFollow)
          isClean = true;
        Robot.debugOut.sayToast("Cleaning Done");
        if (currentStrategy == boustrophedon)
          currentStrategy = wallFollow;
        Robot.debugOut.sayToast("Boustrophedon Done - Switching to Wall Follow");
        continue;
      }

      double[] targetPos = currentStrategy.getWorldCoordinateForTarget(nextTarget);
      try {
        // Attempt to clean at the target's position
        driveToTarget(targetPos[0], targetPos[1]);

        // Mark cell as clean
        synchronized (grid) {
          Cell c = grid.get(nextTarget);
          grid.set(nextTarget, c.with(Cell.CLEAN));
        }

        // Draw cleaning path
        double[] startingPos = grid.gridToWorld(currentPos);
        double[] endingPos = grid.gridToWorld(nextTarget);
        int redChannel = currentStrategy == wallFollow ? 255 : 0;
        pathOverlay.drawArrow(startingPos[0], startingPos[1], endingPos[0], endingPos[1], 5, redChannel, 0, 0, 255);

        currentPos = nextTarget;
      } catch (Exception e) {
        // Couldn't get route to target -- target is unreachable
        Robot.debugOut.println("couldn't reach cell " + nextTarget + ": " + e.getMessage());
        synchronized (grid) {
          byte cellMarker = currentStrategy == boustrophedon ? Cell.OBSTACLE : Cell.UNREACHABLE;
          grid.set(nextTarget, grid.get(nextTarget).with(cellMarker));
        }
      }

      // Update visual grid
      grid.paint(Robot.debugPainter.getOverlay("Grid"));
    }

    // Return back to start
    Robot.debugOut.sayToast("Cleaning done, returning home");
    driveToTarget(startPos[0], startPos[1]);
    Robot.debugOut.sayToast("bye! ^^");
  }

  private void driveToTarget(double x, double y) throws Exception {
    robotDriver.driveTo(x, y);
    while (isRunning() && !robotDriver.targetReached()) {
      // Continue driving
      Time.sleep(10);
      robotDriver.waitForTarget();
    }
  }

  @Override
  public void pause() throws Exception {
    if (Robot.lidarSubsystem != null) {
      Robot.lidarSubsystem.shutdown();
    }
    if (robotDriver != null)
      robotDriver.halt(Driver.HALT_REASON_CONTROLLER_PAUSE);
  }

  @Override
  public void stop() throws Exception {
    if (Robot.lidarSubsystem != null) {
      Robot.lidarSubsystem.shutdown();
    }

    if (robotDriver != null)
      robotDriver.halt(Driver.HALT_REASON_CONTROLLER_STOP);
    obstaclesLidar.clear();
  }

  @Override
  public void mssResponse(ArrayList<String> messages, int responseType)
      throws Exception {
    if (MotionSubsystemListener.isFailureResponse(responseType))
      Robot.debugOut.println("Failure response " + messages.get(0));
  }

  @Override
  public void mssAsyncMessages(
      ArrayList<String> messages,
      AsyncMotionMessageBundle bundle) throws Exception {
    // Forward to robot driver
    robotDriver.mssAsyncMessages(messages, bundle);
  }

  @Override
  public void observedLidarPointsSlam(LidarPackageSlam lidarPackageSlam) throws Exception {
    if (!lidarPackageSlam.isSuccessful())
      return; // Lidar Scan war nicht erfolgreich -> Nichts tun

    // Forward to robot driver
    PointList2D<ObstaclePoint> newObstacles = robotDriver.observedLidarPointsSlam(lidarPackageSlam);

    // Add new obstacles to grid
    synchronized (grid) {
      if (newObstacles != null) {
        for (ObstaclePoint point : newObstacles) {
          Coordinate coord = grid.worldToGrid(point.get2D());
          Cell cell = grid.get(coord);

          if (cell.hasNone(Cell.OBSTACLE)) {
            grid.set(coord, cell.with(Cell.OBSTACLE));
          }
        }
      }
    }

    // Draw (new) obstacles
    grid.paint(Robot.debugPainter.getOverlay("Grid"));
    paintObstacles();
  }
}
