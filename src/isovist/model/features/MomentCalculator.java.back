package isovist.model.features;

import robotinterface.debug.DebugPainterOverlay;
import robotinterface.Robot;

import basics.points.Point;
import basics.points.PointList2D;

public class MomentCalculator {

    private static final double EPS = 1e-5;

    public static double[] computeMomentValues(PointList2D<Point> points, double[] pos) {
        if (points.size() < 3) return null;

        double a1Sum = 0;
        double a2Sum = 0;
        double a3Sum = 0;

				DebugPainterOverlay overlay = Robot.debugPainter.getOverlay("Raw LiDAR Points");
				overlay.clear();

				int step = 25;

        for (int i = 0; i < points.size(); i += step) {
            Point cur = points.get(i);
            Point next = (i + step >= points.size()) ? points.get(points.size() - (i + step)) : points.get(i + step);

            double a = cur.distanceTo2D(pos[0], pos[1]);
            double b = next.distanceTo2D(pos[0], pos[1]);
            double c = cur.distanceTo2D(next);

						overlay.drawLine(0, 0, cur.getX(), cur.getY(), 0, 0, 0, 100);
						overlay.drawLine(0, 0, next.getX(), next.getY(), 255, 0, 0, 100);

            if (a == 0 || b == 0 || c == 0) continue;

            double[] angles = computeAngles(a, b, c);
            double alpha = angles[0];
            double beta = angles[1];
            double gamma = angles[2];

            if (Double.isNaN(alpha) || Double.isNaN(beta) || Double.isNaN(gamma)) continue;

            double _a1 = computeA1(a, b, c, gamma);
            double _a2 = computeA2(a, b, c, alpha, beta, gamma);
            double _a3 = computeA3(a, b, c, alpha, beta, gamma);

            if (Double.isNaN(_a1) || Double.isNaN(_a2) || Double.isNaN(_a3)) continue;

						if (_a1 > 1e6 || _a2 > 1e6 || _a3 > 1e6) {
    System.out.printf("[DEBUG] Huge moments at i=%d\n", i);
    System.out.printf("Lengths: a=%.3f, b=%.3f, c=%.3f\n", a, b, c);
    System.out.printf("Angles: alpha=%.5f, beta=%.5f, gamma=%.5f\n", alpha, beta, gamma);
    System.out.printf("Moments: A1=%.5e, A2=%.5e, A3=%.5e\n\n", _a1, _a2, _a3);
}

            a1Sum += _a1;
            a2Sum += _a2;
            a3Sum += _a3;
        }
overlay.paint();

        double a1 = a1Sum / (2 * Math.PI);
        double a2 = a2Sum / (2 * Math.PI);
        double a3 = a3Sum / (2 * Math.PI);

        double m1 = a1;
        double m2 = a2 - m1 * m1;
        double m3 = a3 - 3 * m1 * a2 + 2 * m1 * m1 * m1;

				System.out.println("MOMENTS: " + m1);
				System.out.println("MOMENTS: " + m2);
				System.out.println("MOMENTS: " + m3);

        return new double[] { m1, m2, m3 };
    }

    private static double[] computeAngles(double a, double b, double c) {
        double cosGamma = (a * a + b * b - c * c) / (2 * a * b);
        double cosAlpha = (b * b + c * c - a * a) / (2 * b * c);
        double cosBeta =  (a * a + c * c - b * b) / (2 * a * c);

        double gamma = Math.acos(clamp(cosGamma, -1.0, 1.0));
        double alpha = Math.acos(clamp(cosAlpha, -1.0, 1.0));
        double beta = Math.acos(clamp(cosBeta, -1.0, 1.0));

        return new double[] { alpha, beta, gamma };
    }

    private static double computeA1(double a, double b, double c, double gamma) {
        double _1st = a * b / c;
        double _2nd = Math.sin(gamma) / gamma;

        double cosGamma = Math.cos(gamma);
        double _3rdNum = (c + a - b * cosGamma) * (c + b - a * cosGamma);
        double _3rdDenom = a * b * Math.pow(Math.sin(gamma), 2);
        if (_3rdDenom < EPS || _3rdNum <= 0) return Double.NaN;
        double _3rd = Math.log(_3rdNum / _3rdDenom);

        return _1st * _2nd * _3rd;
    }

    private static double computeA2(double a, double b, double c, double alpha, double beta, double gamma) {
        double _1st = 1 / gamma;
        double _2nd = Math.pow(a * b * Math.sin(gamma) / c, 2);
        double cotAlpha = cot(alpha);
        double cotBeta = cot(beta);
        if (Double.isNaN(cotAlpha) || Double.isNaN(cotBeta)) return Double.NaN;
        double _3rd = cotAlpha + cotBeta;

        return _1st * _2nd * _3rd;
    }

    private static double computeA3(double a, double b, double c, double alpha, double beta, double gamma) {
        double _1st = 1 / (2 * gamma);
        double _2nd = Math.pow(a * b * Math.sin(gamma) / c, 3);

        double cosecAlpha = cosec(alpha);
        double cotAlpha = cot(alpha);
        double cosecBeta = cosec(beta);
        double cotBeta = cot(beta);

        if (Double.isNaN(cosecAlpha) || Double.isNaN(cosecBeta) ||
            Double.isNaN(cotAlpha) || Double.isNaN(cotBeta)) return Double.NaN;

        double _3rdLeft = cosecAlpha * cotAlpha + cosecBeta * cotBeta;
        double _3rdRight = Math.log((cosecAlpha + cotAlpha) * (cosecBeta + cotBeta));
        double _3rd = _3rdLeft + _3rdRight;

        return _1st * _2nd * _3rd;
    }

    private static double cot(double angle) {
        if (angle < 1e-3 || Math.abs(angle - Math.PI) < 1e-3) return Double.NaN;
        double tan = Math.tan(angle);
        return Math.abs(tan) < EPS ? Double.NaN : 1 / tan;
    }

    private static double cosec(double angle) {
        if (angle < 1e-3 || Math.abs(angle - Math.PI) < 1e-3) return Double.NaN;
        double sin = Math.sin(angle);
        return Math.abs(sin) < EPS ? Double.NaN : 1 / sin;
    }

    private static double clamp(double val, double min, double max) {
        return Math.max(min, Math.min(max, val));
    }
} 





// OLD THINGS FROM ME
/*



	// =====

	static double[] computeMomentValues(PointList2D<Point> points, double[] pos) {
		if (points.size() < 3) return null;

		double a1Sum = 0;
		double a2Sum = 0;
		double a3Sum = 0;

		for (int i = 0; i < points.size(); ++i) {
			Point curr = points.get(i);
			Point next = getNext(points, i);

			double[] lengths = new double[]
			{
				curr.distanceTo2D(pos[0], pos[1]),
				next.distanceTo2D(pos[0], pos[1]),
				curr.distanceTo2D(next)
			};
			if (lengths[0] == 0 || lengths[1] == 0 || lengths[2] == 0) 
			{
				// System.out.println("PP AT: " + i);
				// System.out.println("pos: " + pos[0] + "/" + pos[1]);
				// System.out.println("curr: " + curr.toString());
				// System.out.println("next: " + next.toString());
				// for (double v : lengths) System.out.println("LENGTH: " + v);
				// System.out.println("---");
				continue;
			}
			// System.out.println("triangle for: " + i);

			// ORM SCALE
			double maxLen = Math.max(lengths[0], Math.max(lengths[1], lengths[2]));
			if (maxLen > 1e-6) {
				for (int j = 0; j < 3; j++) lengths[j] /= maxLen;
				System.out.println("scaled");
			}

			double[] angles = computeAngles(lengths);
			if (Double.isNaN(angles[0]) || Double.isNaN(angles[1]) || Double.isNaN(angles[2])) continue;
			// if (angles[0] < 0.01 || angles[1] < 0.01 || angles[2] < 0.01) continue;
			// System.out.println("angles for: " + i);
			// for (double v : angles) System.out.println("- : " + v);

			double _a1 = computeA1(lengths, angles);
			double _a2 = computeA2(lengths, angles);
			double _a3 = computeA3(lengths, angles);

			// DEBUG: meo
			if (Double.isNaN(_a1) || Double.isNaN(_a2) || Double.isNaN(_a3)) {
					System.out.println("Suspect triangle at index " + i);
					System.out.println("Lengths: " + Arrays.toString(lengths));
					System.out.println("Angles: " + Arrays.toString(angles));
					System.out.println("cot(α): " + cot(angles[0]) + ", cot(β): " + cot(angles[1]));
					System.out.println("cosec(α): " + cosec(angles[0]) + ", cosec(β): " + cosec(angles[1]));
					if (Double.isNaN(cot(angles[0])) || Double.isNaN(cot(angles[1])))
						System.out.println("COT!");
					if (Double.isNaN(cosec(angles[0])) || Double.isNaN(cosec(angles[1])))
						System.out.println("-- COSEC!");
			}

			if (Double.isNaN(_a1) || Double.isNaN(_a2) || Double.isNaN(_a3)) {
				// System.out.println("IS NAN at "+i);
				continue;
			};

			// System.out.println("-- moments " + i + " --");
			// System.out.println(_a1);
			// System.out.println(_a2);
			// System.out.println(_a3);

			if (_a1 > 1e6 || _a2 > 1e6 || _a3 > 1e6) {
				// System.out.println("Large moment at triangle " + i);
				// System.out.println("Lengths: " + Arrays.toString(lengths));
				// System.out.println("Angles: " + Arrays.toString(angles));

				continue;
			}
			System.out.println("computed i = " + i);

			a1Sum += _a1;
			a2Sum += _a2;
			a3Sum += _a3;
		}

		double a1 = a1Sum / (2 * Math.PI);
		double a2 = a2Sum / (2 * Math.PI);
		double a3 = a3Sum / (2 * Math.PI);

		double m1 = a1;
		double m2 = a2 - m1 * m1;
		double m3 = a3 - 3 * m1 * a2 + 2 * m1 * m1 * m1;

		if (m1 == 0)
			System.out.println("-- no moments");


		return new double[] { m1, m2, m3 };
	}
	static double[] computeAngles(double[] lengths) {
		double cosGamma = (lengths[0] * lengths[0] + lengths[1] * lengths[1] - lengths[2] * lengths[2]) / (2 * lengths[0] * lengths[1]);
		double cosAlpha = (lengths[1] * lengths[1] + lengths[2] * lengths[2] - lengths[0] * lengths[0]) / (2 * lengths[1] * lengths[2]);
		double cosBeta  = (lengths[0] * lengths[0] + lengths[2] * lengths[2] - lengths[1] * lengths[1]) / (2 * lengths[0] * lengths[2]);

		double clampedCosGamma = FeatureUtils.clamp(cosGamma, -1.0, 1.0);
		double clampedCosAlpha = FeatureUtils.clamp(cosAlpha, -1.0, 1.0);
		double clampedCosBeta =  FeatureUtils.clamp(cosBeta, -1.0, 1.0);

		double gamma = Math.acos(clampedCosGamma);
		double alpha = Math.acos(clampedCosAlpha);
		double beta = Math.acos(clampedCosBeta);

  	return new double[] { alpha, beta, gamma };
	}
	static double computeA1(double[] lengths, double[] angles) {
		double _1st = lengths[0] * lengths[1] / lengths[2];
		double _2nd = Math.sin(angles[2]) / angles[2];
		double cosGamma = Math.cos(angles[2]);
		double _3rdNum = (lengths[2] + lengths[0] - lengths[1] * cosGamma) * (lengths[2] + lengths[1] - lengths[0] * cosGamma);
		double _3rdDenom = lengths[0] * lengths[1] * Math.pow(Math.sin(angles[2]), 2);
		if (FeatureUtils.isEPS(_3rdDenom)) return Double.NaN;
		double _3rd = Math.log(_3rdNum / _3rdDenom);
		return _1st * _2nd * _3rd;
	}
	static double computeA2(double[] lengths, double[] angles) {
		double _1st = 1 / angles[2];
		double _2nd = Math.pow(lengths[0] * lengths[1] * Math.sin(angles[2]) / lengths[2], 2);
		double _3rd = cot(angles[0]) + cot(angles[1]);
		return _1st * _2nd * _3rd;
	}
	static double computeA3(double[] lengths, double[] angles) {
		double _1st = 1 / (2 * angles[2]);
		double _2nd = Math.pow(lengths[0] * lengths[1] * Math.sin(angles[2]) / lengths[2], 3);

		double cosecAlpha = cosec(angles[0]);
		double cotAlpha = cot(angles[0]);
		double cosecBeta = cosec(angles[1]);
		double cotBeta = cot(angles[1]);
		double _3rdLeft = cosecAlpha * cotAlpha + cosecBeta * cotBeta;
		double _3rdRight = Math.log((cosecAlpha + cotAlpha) * (cosecBeta + cotBeta));
		double _3rd = _3rdLeft + _3rdRight;

		return _1st * _2nd * _3rd;
	}
	// public static double cot(double angle) { return 1 / FeatureUtils.withEPS(Math.tan(angle < 1e-3 ? Double.NaN : angle)); }
	public static double cosec(double angle) { return 1 / FeatureUtils.withEPS(Math.sin(angle < 1e-3 ? Double.NaN : angle)); }

public static double cot(double angle) {
if (angle < 1e-2 || Math.abs(angle - Math.PI) < 1e-2) {
    System.out.println("cot() skipped due to small angle: " + angle);
    return Double.NaN;
}
    double tan = Math.tan(angle);
    if (Math.abs(tan) < 1e-5) 
{

    System.out.println("cot() skipped due tan too small: " + tan);
	return Double.NaN;
}
    return 1 / tan;
}


*/
